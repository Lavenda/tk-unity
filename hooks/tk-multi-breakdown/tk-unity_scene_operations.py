import unity_connection

import sgtk

import json
import os
import sys

# Fix-up sys.path so we can access our utils
utils_path = os.path.split(__file__)[0]
utils_path = os.path.join(utils_path, os.pardir, 'utils')
utils_path = os.path.normpath(utils_path)
if utils_path not in sys.path:
    sys.path.append(utils_path)

import asset_import

HookBaseClass = sgtk.get_hook_baseclass()

class BreakdownSceneOperations(HookBaseClass):
    """
    Breakdown operations for Unity.

    This implementation handles detection of fbx files in Unity that contain Shotgun meta data.
    """

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of assets that are
        to be potentially operated on.

        The return data structure is a list of dictionaries. Each scene asset
        that is returned should be represented by a dictionary with three keys:

        - "node": The asset path
        - "type": Always equal to 'file' for the current implementation
        - "path": Path on disk to the referenced asset (in the defined storage for the project)  

        Toolkit will scan the list of items, see if any of the objects matches
        any templates and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.
        """
        
        import unity_connection
        UnityEditor = unity_connection.get_module('UnityEditor')
        refs = []
        
        # check the meta data of all fbx files in the project to see if they contain a shotgun path, add them if they do
        guids = UnityEditor.AssetDatabase.FindAssets("t:model")
        for guid in guids:
            path = UnityEditor.AssetDatabase.GUIDToAssetPath(guid)
            extension = os.path.splitext(path)[1] 
            if extension.lower() != ".fbx":
                continue # ignore potentially finding other files
                
            model_importer = UnityEditor.AssetImporter.GetAtPath(path)
            if not model_importer:
                self.logger.warning('Ignoring file "{}" because there is no associated asset importer'.format(path))
                continue
            
            userdata_path = None
            try:
                userdata = json.loads(model_importer.userData)
                userdata_path = userdata['path'] 
            except:
                # This might be an asset that was imported with the alpha 
                # version of the engine, when userData was set to the path
                # (instead of a json dictionary)
                userdata_path = model_importer.userData
                
            item = {}
            item["type"] = "file"
            item["node"] = os.path.splitext(path)[0]
            item["path"] = userdata_path
            refs.append(item)
        return refs

    def update(self, items):
        """
        Perform replacements given a number of items passed from the app.

        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.

        The items parameter is a list of dictionaries on the same form as was
        generated by the scan_scene hook above. The path key now holds
        the file that each node should be updated *to* rather than the current path.
        """
        
        UnityEngine = unity_connection.get_module('UnityEngine')
        project_folder = UnityEngine.Application.dataPath
        for item in items:
            src_file = item.get("path")
            asset_rel_path = item.get("node")

            asset_name = asset_rel_path.split('/')[-1]
            asset_directory = '/'.join(asset_rel_path.split('/')[1:-1])
            dst_dir = os.path.join(project_folder, asset_directory)

            asset_import.import_file(src_file, asset_name, dst_dir)
