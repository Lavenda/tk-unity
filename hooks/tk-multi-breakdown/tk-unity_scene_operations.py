# Copyright (c) 2013 Shotgun Software Inc.
#
# CONFIDENTIAL AND PROPRIETARY
#
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights
# not expressly granted therein are reserved by Shotgun Software Inc.

from tank import Hook
import os

class BreakdownSceneOperations(Hook):
    """
    Breakdown operations for Unity.

    This implementation handles detection of fbx files in Unity that contain shotgun meta data.
    """

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of assets that are
        to be potentially operated on.

        The return data structure is a list of dictionaries. Each scene asset
        that is returned should be represented by a dictionary with three keys:

        - "node": The name of the 'node' that is to be operated on. Most DCCs have
          a concept of a node, path or some other way to address a particular
          object in the scene.
        - "type": The object type that this is. This is later passed to the
          update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.

        Toolkit will scan the list of items, see if any of the objects matches
        any templates and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.
        """
        
        import UnityEditor
        refs = []
        
        # check the meta data of all fbx files in the project to see if they contain a shotgun path, add them if they do
        guids = UnityEditor.AssetDatabase.FindAssets("t:model")
        for guid in guids:
            path = UnityEditor.AssetDatabase.GUIDToAssetPath(guid)
            extension = os.path.splitext(path)[1] 
            if extension.lower() != ".fbx":
                continue # ignore potentially finding other files
                
            modelImporter = UnityEditor.AssetImporter.GetAtPath(path)
            if not modelImporter:
                continue
                
            item = {}
            item["type"] = "file"
            item["node"] = os.path.splitext(path)[0]
            item["path"] = modelImporter.userData
            refs.append(item)
        return refs

    def update(self, items):
        """
        Perform replacements given a number of scene items passed from the app.

        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.

        The items parameter is a list of dictionaries on the same form as was
        generated by the scan_scene hook above. The path key now holds
        the that each node should be updated *to* rather than the current path.
        """
        
        import shutil
        import UnityEngine
        import UnityEditor
        for item in items:
            # replace the item in Assets with the updated version at path
            projectFolder = os.path.dirname(UnityEngine.Application.dataPath)
            
            assetRelPath = item.get("node", None)
            updatePath = item.get("path", None)
            if not assetRelPath or not updatePath:
                continue
            
            try:
                assetRelPath = "{0}.fbx".format(assetRelPath)
                shutil.copy2(updatePath, os.path.join(projectFolder, assetRelPath))
                
                # update the path in the meta file     
                UnityEditor.AssetDatabase.ImportAsset(assetRelPath)
                modelImporter = UnityEditor.AssetImporter.GetAtPath(assetRelPath)
                modelImporter.userData = updatePath
                UnityEditor.AssetDatabase.ImportAsset(assetRelPath)
            except IOError as e:
                UnityEngine.Debug.LogError("IOError: {0}".format(str(e)))    
